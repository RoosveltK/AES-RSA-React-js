{"ast":null,"code":"import Aes from \"./Aes.js\";\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\n\nclass AesCtr extends Aes {\n  /**\n   * Encrypt a text using AES encryption in Counter mode of operation.\n   *\n   * Unicode multi-byte character safe.\n   *\n   * @param   {string} plaintext - Source text to be encrypted.\n   * @param   {string} password - The password to use to generate a key for encryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Encrypted text, base-64 encoded.\n   *\n   * @example\n   *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n   */\n  static encrypt(plaintext, password, nBits) {\n    if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n    plaintext = AesCtr.utf8Encode(String(plaintext));\n    password = AesCtr.utf8Encode(String(password)); // use AES itself to encrypt password to get cipher key (using plain password as source for key\n    // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n\n    const nBytes = nBits / 8; // no bytes in key (16/24/32)\n\n    const pwBytes = new Array(nBytes);\n\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st 16/24/32 chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n    // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n    // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n\n    const timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n\n    const nonceMs = timestamp % 1000;\n    const nonceSec = Math.floor(timestamp / 1000);\n    const nonceRnd = Math.floor(Math.random() * 0xffff); // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n\n    const counterBlock = [// 16-byte array; blocksize is fixed at 16 for AES\n    nonceMs & 0xff, nonceMs >>> 8 & 0xff, nonceRnd & 0xff, nonceRnd >>> 8 & 0xff, nonceSec & 0xff, nonceSec >>> 8 & 0xff, nonceSec >>> 16 & 0xff, nonceSec >>> 24 & 0xff, 0, 0, 0, 0, 0, 0, 0, 0]; // and convert nonce to a string to go on the front of the ciphertext\n\n    const nonceStr = counterBlock.slice(0, 8).map(i => String.fromCharCode(i)).join(\"\"); // convert (utf-8) plaintext to byte array\n\n    const plaintextBytes = plaintext.split(\"\").map(ch => ch.charCodeAt(0)); // ------------ perform encryption ------------\n\n    const ciphertextBytes = AesCtr.nistEncryption(plaintextBytes, key, counterBlock); // convert byte array to (utf-8) ciphertext string\n\n    const ciphertextUtf8 = ciphertextBytes.map(i => String.fromCharCode(i)).join(\"\"); // base-64 encode ciphertext\n\n    const ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n    return ciphertextB64;\n  }\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n   *   ciphertext blocks\n   *\n   * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n   * @param   {number[]} key - Key to be used to encrypt plaintext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Ciphertext as byte array.\n   *\n   * @private\n   */\n\n\n  static nistEncryption(plaintext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n    const keySchedule = Aes.keyExpansion(key);\n    const blockCount = Math.ceil(plaintext.length / blockSize);\n    const ciphertext = new Array(plaintext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n      const blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1; // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n\n      for (let i = 0; i < blockLength; i++) {\n        ciphertext[b * blockSize + i] = cipherCntr[i] ^ plaintext[b * blockSize + i];\n      } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n      counterBlock[blockSize - 1]++; // and propagate carry digits\n\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n      if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (b % 1000 == 0) self.postMessage({\n          progress: b / blockCount\n        });\n      }\n    }\n\n    return ciphertext;\n  }\n  /**\n   * Decrypt a text encrypted by AES in counter mode of operation.\n   *\n   * @param   {string} ciphertext - Cipher text to be decrypted.\n   * @param   {string} password - Password to use to generate a key for decryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Decrypted text\n   *\n   * @example\n   *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n   */\n\n\n  static decrypt(ciphertext, password, nBits) {\n    if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n    ciphertext = AesCtr.base64Decode(String(ciphertext));\n    password = AesCtr.utf8Encode(String(password)); // use AES to encrypt password (mirroring encrypt routine)\n\n    const nBytes = nBits / 8; // no bytes in key\n\n    const pwBytes = new Array(nBytes);\n\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st nBytes chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n    // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n\n    const counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    for (let i = 0; i < 8; i++) counterBlock[i] = ciphertext.charCodeAt(i); // convert ciphertext to byte array (skipping past initial 8 bytes)\n\n\n    const ciphertextBytes = new Array(ciphertext.length - 8);\n\n    for (let i = 8; i < ciphertext.length; i++) ciphertextBytes[i - 8] = ciphertext.charCodeAt(i); // ------------ perform decryption ------------\n\n\n    const plaintextBytes = AesCtr.nistDecryption(ciphertextBytes, key, counterBlock); // convert byte array to (utf-8) plaintext string\n\n    const plaintextUtf8 = plaintextBytes.map(i => String.fromCharCode(i)).join(\"\"); // decode from UTF8 back to Unicode multi-byte chars\n\n    const plaintext = AesCtr.utf8Decode(plaintextUtf8);\n    return plaintext;\n  }\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n   *   plaintext blocks\n   *\n   * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n   * @param   {number[]} key - Key to be used to decrypt ciphertext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Plaintext as byte array.\n   *\n   * @private\n   */\n\n\n  static nistDecryption(ciphertext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n    const keySchedule = Aes.keyExpansion(key);\n    const blockCount = Math.ceil(ciphertext.length / blockSize);\n    const plaintext = new Array(ciphertext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n      const blockLength = b < blockCount - 1 ? blockSize : (ciphertext.length - 1) % blockSize + 1; // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n\n      for (let i = 0; i < blockLength; i++) {\n        plaintext[b * blockSize + i] = cipherCntr[i] ^ ciphertext[b * blockSize + i];\n      } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n      counterBlock[blockSize - 1]++; // and propagate carry digits\n\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n      if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (b % 1000 == 0) self.postMessage({\n          progress: b / blockCount\n        });\n      }\n    }\n\n    return plaintext;\n  }\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n  /**\n   * Encodes multi-byte string to utf8.\n   *\n   * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n   * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n   */\n\n\n  static utf8Encode(str) {\n    try {\n      return new TextEncoder().encode(str, \"utf-8\").reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n  /**\n   * Decodes utf8 string to multi-byte.\n   */\n\n\n  static utf8Decode(str) {\n    try {\n      return new TextEncoder().decode(str, \"utf-8\").reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n  /*\n   * Encodes string as base-64.\n   *\n   * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n   * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n   * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n   */\n\n\n  static base64Encode(str) {\n    if (typeof btoa != \"undefined\") return btoa(str); // browser\n\n    if (typeof Buffer != \"undefined\") return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n\n    throw new Error(\"No Base64 Encode\");\n  }\n  /*\n   * Decodes base-64 encoded string.\n   */\n\n\n  static base64Decode(str) {\n    if (typeof atob != \"undefined\") return atob(str); // browser\n\n    if (typeof Buffer != \"undefined\") return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n\n    throw new Error(\"No Base64 Decode\");\n  }\n\n}\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport default AesCtr;","map":null,"metadata":{},"sourceType":"module"}