{"ast":null,"code":"import _classCallCheck from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport Aes from \"./Aes.js\";\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\n\nvar AesCtr = /*#__PURE__*/function (_Aes) {\n  _inherits(AesCtr, _Aes);\n\n  var _super = _createSuper(AesCtr);\n\n  function AesCtr() {\n    _classCallCheck(this, AesCtr);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AesCtr, null, [{\n    key: \"encrypt\",\n\n    /**\n     * Encrypt a text using AES encryption in Counter mode of operation.\n     *\n     * Unicode multi-byte character safe.\n     *\n     * @param   {string} plaintext - Source text to be encrypted.\n     * @param   {string} password - The password to use to generate a key for encryption.\n     * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n     * @returns {string} Encrypted text, base-64 encoded.\n     *\n     * @example\n     *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n     */\n    value: function encrypt(plaintext, password, nBits) {\n      if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n      plaintext = AesCtr.utf8Encode(String(plaintext));\n      password = AesCtr.utf8Encode(String(password)); // use AES itself to encrypt password to get cipher key (using plain password as source for key\n      // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n\n      var nBytes = nBits / 8; // no bytes in key (16/24/32)\n\n      var pwBytes = new Array(nBytes);\n\n      for (var i = 0; i < nBytes; i++) {\n        // use 1st 16/24/32 chars of password for key\n        pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n      }\n\n      var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n\n      key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n      // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n      // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n\n      var timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n\n      var nonceMs = timestamp % 1000;\n      var nonceSec = Math.floor(timestamp / 1000);\n      var nonceRnd = Math.floor(Math.random() * 0xffff); // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n\n      var counterBlock = [// 16-byte array; blocksize is fixed at 16 for AES\n      nonceMs & 0xff, nonceMs >>> 8 & 0xff, nonceRnd & 0xff, nonceRnd >>> 8 & 0xff, nonceSec & 0xff, nonceSec >>> 8 & 0xff, nonceSec >>> 16 & 0xff, nonceSec >>> 24 & 0xff, 0, 0, 0, 0, 0, 0, 0, 0]; // and convert nonce to a string to go on the front of the ciphertext\n\n      var nonceStr = counterBlock.slice(0, 8).map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // convert (utf-8) plaintext to byte array\n\n      var plaintextBytes = plaintext.split(\"\").map(function (ch) {\n        return ch.charCodeAt(0);\n      }); // ------------ perform encryption ------------\n\n      var ciphertextBytes = AesCtr.nistEncryption(plaintextBytes, key, counterBlock); // convert byte array to (utf-8) ciphertext string\n\n      var ciphertextUtf8 = ciphertextBytes.map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // base-64 encode ciphertext\n\n      var ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n      return ciphertextB64;\n    }\n    /**\n     * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n     * operations. This implements the §6.5 Counter Mode (CTR).\n     *\n     *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n     *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n     *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n     *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n     *   ciphertext blocks\n     *\n     * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n     * @param   {number[]} key - Key to be used to encrypt plaintext.\n     * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n     * @returns {number[]} Ciphertext as byte array.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"nistEncryption\",\n    value: function nistEncryption(plaintext, key, counterBlock) {\n      var blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n      // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n      var keySchedule = Aes.keyExpansion(key);\n      var blockCount = Math.ceil(plaintext.length / blockSize);\n      var ciphertext = new Array(plaintext.length);\n\n      for (var b = 0; b < blockCount; b++) {\n        // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n        var blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1; // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n\n        for (var i = 0; i < blockLength; i++) {\n          ciphertext[b * blockSize + i] = cipherCntr[i] ^ plaintext[b * blockSize + i];\n        } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n        counterBlock[blockSize - 1]++; // and propagate carry digits\n\n        for (var _i = blockSize - 1; _i >= 8; _i--) {\n          counterBlock[_i - 1] += counterBlock[_i] >> 8;\n          counterBlock[_i] &= 0xff;\n        } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n        if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n          if (b % 1000 == 0) self.postMessage({\n            progress: b / blockCount\n          });\n        }\n      }\n\n      return ciphertext;\n    }\n    /**\n     * Decrypt a text encrypted by AES in counter mode of operation.\n     *\n     * @param   {string} ciphertext - Cipher text to be decrypted.\n     * @param   {string} password - Password to use to generate a key for decryption.\n     * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n     * @returns {string} Decrypted text\n     *\n     * @example\n     *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext, password, nBits) {\n      if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n      ciphertext = AesCtr.base64Decode(String(ciphertext));\n      password = AesCtr.utf8Encode(String(password)); // use AES to encrypt password (mirroring encrypt routine)\n\n      var nBytes = nBits / 8; // no bytes in key\n\n      var pwBytes = new Array(nBytes);\n\n      for (var i = 0; i < nBytes; i++) {\n        // use 1st nBytes chars of password for key\n        pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n      }\n\n      var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n      key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n      // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n\n      var counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n      for (var _i2 = 0; _i2 < 8; _i2++) {\n        counterBlock[_i2] = ciphertext.charCodeAt(_i2);\n      } // convert ciphertext to byte array (skipping past initial 8 bytes)\n\n\n      var ciphertextBytes = new Array(ciphertext.length - 8);\n\n      for (var _i3 = 8; _i3 < ciphertext.length; _i3++) {\n        ciphertextBytes[_i3 - 8] = ciphertext.charCodeAt(_i3);\n      } // ------------ perform decryption ------------\n\n\n      var plaintextBytes = AesCtr.nistDecryption(ciphertextBytes, key, counterBlock); // convert byte array to (utf-8) plaintext string\n\n      var plaintextUtf8 = plaintextBytes.map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // decode from UTF8 back to Unicode multi-byte chars\n\n      var plaintext = AesCtr.utf8Decode(plaintextUtf8);\n      return plaintext;\n    }\n    /**\n     * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n     * operations. This implements the §6.5 Counter Mode (CTR).\n     *\n     *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n     *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n     *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n     *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n     *   plaintext blocks\n     *\n     * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n     * @param   {number[]} key - Key to be used to decrypt ciphertext.\n     * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n     * @returns {number[]} Plaintext as byte array.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"nistDecryption\",\n    value: function nistDecryption(ciphertext, key, counterBlock) {\n      var blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n      // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n      var keySchedule = Aes.keyExpansion(key);\n      var blockCount = Math.ceil(ciphertext.length / blockSize);\n      var plaintext = new Array(ciphertext.length);\n\n      for (var b = 0; b < blockCount; b++) {\n        // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n        var blockLength = b < blockCount - 1 ? blockSize : (ciphertext.length - 1) % blockSize + 1; // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n\n        for (var i = 0; i < blockLength; i++) {\n          plaintext[b * blockSize + i] = cipherCntr[i] ^ ciphertext[b * blockSize + i];\n        } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n        counterBlock[blockSize - 1]++; // and propagate carry digits\n\n        for (var _i4 = blockSize - 1; _i4 >= 8; _i4--) {\n          counterBlock[_i4 - 1] += counterBlock[_i4] >> 8;\n          counterBlock[_i4] &= 0xff;\n        } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n        if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n          if (b % 1000 == 0) self.postMessage({\n            progress: b / blockCount\n          });\n        }\n      }\n\n      return plaintext;\n    }\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n    /**\n     * Encodes multi-byte string to utf8.\n     *\n     * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n     * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n     */\n\n  }, {\n    key: \"utf8Encode\",\n    value: function utf8Encode(str) {\n      try {\n        return new TextEncoder().encode(str, \"utf-8\").reduce(function (prev, curr) {\n          return prev + String.fromCharCode(curr);\n        }, \"\");\n      } catch (e) {\n        // no TextEncoder available?\n        return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n      }\n    }\n    /**\n     * Decodes utf8 string to multi-byte.\n     */\n\n  }, {\n    key: \"utf8Decode\",\n    value: function utf8Decode(str) {\n      try {\n        return new TextEncoder().decode(str, \"utf-8\").reduce(function (prev, curr) {\n          return prev + String.fromCharCode(curr);\n        }, \"\");\n      } catch (e) {\n        // no TextEncoder available?\n        return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n      }\n    }\n    /*\n     * Encodes string as base-64.\n     *\n     * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n     * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n     * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n     */\n\n  }, {\n    key: \"base64Encode\",\n    value: function base64Encode(str) {\n      if (typeof btoa != \"undefined\") return btoa(str); // browser\n\n      if (typeof Buffer != \"undefined\") return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n\n      throw new Error(\"No Base64 Encode\");\n    }\n    /*\n     * Decodes base-64 encoded string.\n     */\n\n  }, {\n    key: \"base64Decode\",\n    value: function base64Decode(str) {\n      if (typeof atob != \"undefined\") return atob(str); // browser\n\n      if (typeof Buffer != \"undefined\") return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n\n      throw new Error(\"No Base64 Decode\");\n    }\n  }]);\n\n  return AesCtr;\n}(Aes);\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport default AesCtr;","map":{"version":3,"sources":["/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/public/AesCtr.js"],"names":["Aes","AesCtr","plaintext","password","nBits","includes","Error","utf8Encode","String","nBytes","pwBytes","Array","i","length","charCodeAt","key","cipher","keyExpansion","concat","slice","timestamp","Date","getTime","nonceMs","nonceSec","Math","floor","nonceRnd","random","counterBlock","nonceStr","map","fromCharCode","join","plaintextBytes","split","ch","ciphertextBytes","nistEncryption","ciphertextUtf8","ciphertextB64","base64Encode","blockSize","keySchedule","blockCount","ceil","ciphertext","b","cipherCntr","blockLength","WorkerGlobalScope","self","postMessage","progress","base64Decode","nistDecryption","plaintextUtf8","utf8Decode","str","TextEncoder","encode","reduce","prev","curr","e","unescape","encodeURIComponent","decode","decodeURIComponent","escape","btoa","Buffer","toString","atob"],"mappings":"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","sourcesContent":["import Aes from \"./Aes.js\";\n\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\nclass AesCtr extends Aes {\n  /**\n   * Encrypt a text using AES encryption in Counter mode of operation.\n   *\n   * Unicode multi-byte character safe.\n   *\n   * @param   {string} plaintext - Source text to be encrypted.\n   * @param   {string} password - The password to use to generate a key for encryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Encrypted text, base-64 encoded.\n   *\n   * @example\n   *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n   */\n  static encrypt(plaintext, password, nBits) {\n    if (![128, 192, 256].includes(nBits))\n      throw new Error(\"Key size is not 128 / 192 / 256\");\n    plaintext = AesCtr.utf8Encode(String(plaintext));\n    password = AesCtr.utf8Encode(String(password));\n\n    // use AES itself to encrypt password to get cipher key (using plain password as source for key\n    // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n    const nBytes = nBits / 8; // no bytes in key (16/24/32)\n    const pwBytes = new Array(nBytes);\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st 16/24/32 chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n\n    // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n    // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n    const timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n    const nonceMs = timestamp % 1000;\n    const nonceSec = Math.floor(timestamp / 1000);\n    const nonceRnd = Math.floor(Math.random() * 0xffff);\n    // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n    const counterBlock = [\n      // 16-byte array; blocksize is fixed at 16 for AES\n      nonceMs & 0xff,\n      (nonceMs >>> 8) & 0xff,\n      nonceRnd & 0xff,\n      (nonceRnd >>> 8) & 0xff,\n      nonceSec & 0xff,\n      (nonceSec >>> 8) & 0xff,\n      (nonceSec >>> 16) & 0xff,\n      (nonceSec >>> 24) & 0xff,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n    ];\n\n    // and convert nonce to a string to go on the front of the ciphertext\n    const nonceStr = counterBlock\n      .slice(0, 8)\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // convert (utf-8) plaintext to byte array\n    const plaintextBytes = plaintext.split(\"\").map((ch) => ch.charCodeAt(0));\n\n    // ------------ perform encryption ------------\n    const ciphertextBytes = AesCtr.nistEncryption(\n      plaintextBytes,\n      key,\n      counterBlock\n    );\n\n    // convert byte array to (utf-8) ciphertext string\n    const ciphertextUtf8 = ciphertextBytes\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // base-64 encode ciphertext\n    const ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n\n    return ciphertextB64;\n  }\n\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n   *   ciphertext blocks\n   *\n   * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n   * @param   {number[]} key - Key to be used to encrypt plaintext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Ciphertext as byte array.\n   *\n   * @private\n   */\n  static nistEncryption(plaintext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n    const keySchedule = Aes.keyExpansion(key);\n\n    const blockCount = Math.ceil(plaintext.length / blockSize);\n    const ciphertext = new Array(plaintext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule);\n\n      // block size is reduced on final block\n      const blockLength =\n        b < blockCount - 1\n          ? blockSize\n          : ((plaintext.length - 1) % blockSize) + 1;\n\n      // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n      for (let i = 0; i < blockLength; i++) {\n        ciphertext[b * blockSize + i] =\n          cipherCntr[i] ^ plaintext[b * blockSize + i];\n      }\n\n      // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n      counterBlock[blockSize - 1]++;\n      // and propagate carry digits\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      }\n\n      // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n      if (\n        typeof WorkerGlobalScope != \"undefined\" &&\n        self instanceof WorkerGlobalScope\n      ) {\n        if (b % 1000 == 0) self.postMessage({ progress: b / blockCount });\n      }\n    }\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypt a text encrypted by AES in counter mode of operation.\n   *\n   * @param   {string} ciphertext - Cipher text to be decrypted.\n   * @param   {string} password - Password to use to generate a key for decryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Decrypted text\n   *\n   * @example\n   *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n   */\n  static decrypt(ciphertext, password, nBits) {\n    if (![128, 192, 256].includes(nBits))\n      throw new Error(\"Key size is not 128 / 192 / 256\");\n    ciphertext = AesCtr.base64Decode(String(ciphertext));\n    password = AesCtr.utf8Encode(String(password));\n\n    // use AES to encrypt password (mirroring encrypt routine)\n    const nBytes = nBits / 8; // no bytes in key\n    const pwBytes = new Array(nBytes);\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st nBytes chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n\n    // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n    const counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let i = 0; i < 8; i++) counterBlock[i] = ciphertext.charCodeAt(i);\n\n    // convert ciphertext to byte array (skipping past initial 8 bytes)\n    const ciphertextBytes = new Array(ciphertext.length - 8);\n    for (let i = 8; i < ciphertext.length; i++)\n      ciphertextBytes[i - 8] = ciphertext.charCodeAt(i);\n\n    // ------------ perform decryption ------------\n    const plaintextBytes = AesCtr.nistDecryption(\n      ciphertextBytes,\n      key,\n      counterBlock\n    );\n\n    // convert byte array to (utf-8) plaintext string\n    const plaintextUtf8 = plaintextBytes\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // decode from UTF8 back to Unicode multi-byte chars\n    const plaintext = AesCtr.utf8Decode(plaintextUtf8);\n\n    return plaintext;\n  }\n\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n   *   plaintext blocks\n   *\n   * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n   * @param   {number[]} key - Key to be used to decrypt ciphertext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Plaintext as byte array.\n   *\n   * @private\n   */\n  static nistDecryption(ciphertext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n    const keySchedule = Aes.keyExpansion(key);\n\n    const blockCount = Math.ceil(ciphertext.length / blockSize);\n    const plaintext = new Array(ciphertext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule);\n\n      // block size is reduced on final block\n      const blockLength =\n        b < blockCount - 1\n          ? blockSize\n          : ((ciphertext.length - 1) % blockSize) + 1;\n\n      // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n      for (let i = 0; i < blockLength; i++) {\n        plaintext[b * blockSize + i] =\n          cipherCntr[i] ^ ciphertext[b * blockSize + i];\n      }\n\n      // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n      counterBlock[blockSize - 1]++;\n      // and propagate carry digits\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      }\n\n      // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n      if (\n        typeof WorkerGlobalScope != \"undefined\" &&\n        self instanceof WorkerGlobalScope\n      ) {\n        if (b % 1000 == 0) self.postMessage({ progress: b / blockCount });\n      }\n    }\n\n    return plaintext;\n  }\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n  /**\n   * Encodes multi-byte string to utf8.\n   *\n   * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n   * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n   */\n  static utf8Encode(str) {\n    try {\n      return new TextEncoder()\n        .encode(str, \"utf-8\")\n        .reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n\n  /**\n   * Decodes utf8 string to multi-byte.\n   */\n  static utf8Decode(str) {\n    try {\n      return new TextEncoder()\n        .decode(str, \"utf-8\")\n        .reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n\n  /*\n   * Encodes string as base-64.\n   *\n   * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n   * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n   * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n   */\n  static base64Encode(str) {\n    if (typeof btoa != \"undefined\") return btoa(str); // browser\n    if (typeof Buffer != \"undefined\")\n      return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n    throw new Error(\"No Base64 Encode\");\n  }\n\n  /*\n   * Decodes base-64 encoded string.\n   */\n  static base64Decode(str) {\n    if (typeof atob != \"undefined\") return atob(str); // browser\n    if (typeof Buffer != \"undefined\")\n      return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n    throw new Error(\"No Base64 Decode\");\n  }\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default AesCtr;\n"]},"metadata":{},"sourceType":"module"}