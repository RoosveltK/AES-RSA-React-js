{"ast":null,"code":"import _classCallCheck from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport Aes from \"./Aes.js\";\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\n\nvar AesCtr = /*#__PURE__*/function (_Aes) {\n  _inherits(AesCtr, _Aes);\n\n  var _super = _createSuper(AesCtr);\n\n  function AesCtr() {\n    _classCallCheck(this, AesCtr);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AesCtr, null, [{\n    key: \"encrypt\",\n\n    /**\n     * Encrypt a text using AES encryption in Counter mode of operation.\n     *\n     * Unicode multi-byte character safe.\n     *\n     * @param   {string} plaintext - Source text to be encrypted.\n     * @param   {string} password - The password to use to generate a key for encryption.\n     * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n     * @returns {string} Encrypted text, base-64 encoded.\n     *\n     * @example\n     *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n     */\n    value: function encrypt(plaintext, password, nBits) {\n      if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n      plaintext = AesCtr.utf8Encode(String(plaintext));\n      password = AesCtr.utf8Encode(String(password)); // use AES itself to encrypt password to get cipher key (using plain password as source for key\n      // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n\n      var nBytes = nBits / 8; // no bytes in key (16/24/32)\n\n      var pwBytes = new Array(nBytes);\n\n      for (var i = 0; i < nBytes; i++) {\n        // use 1st 16/24/32 chars of password for key\n        pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n      }\n\n      var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n\n      key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n      // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n      // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n\n      var timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n\n      var nonceMs = timestamp % 1000;\n      var nonceSec = Math.floor(timestamp / 1000);\n      var nonceRnd = Math.floor(Math.random() * 0xffff); // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n\n      var counterBlock = [// 16-byte array; blocksize is fixed at 16 for AES\n      nonceMs & 0xff, nonceMs >>> 8 & 0xff, nonceRnd & 0xff, nonceRnd >>> 8 & 0xff, nonceSec & 0xff, nonceSec >>> 8 & 0xff, nonceSec >>> 16 & 0xff, nonceSec >>> 24 & 0xff, 0, 0, 0, 0, 0, 0, 0, 0]; // and convert nonce to a string to go on the front of the ciphertext\n\n      var nonceStr = counterBlock.slice(0, 8).map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // convert (utf-8) plaintext to byte array\n\n      var plaintextBytes = plaintext.split(\"\").map(function (ch) {\n        return ch.charCodeAt(0);\n      }); // ------------ perform encryption ------------\n\n      var ciphertextBytes = AesCtr.nistEncryption(plaintextBytes, key, counterBlock); // convert byte array to (utf-8) ciphertext string\n\n      var ciphertextUtf8 = ciphertextBytes.map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // base-64 encode ciphertext\n\n      var ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n      return ciphertextB64;\n    }\n    /**\n     * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n     * operations. This implements the §6.5 Counter Mode (CTR).\n     *\n     *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n     *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n     *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n     *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n     *   ciphertext blocks\n     *\n     * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n     * @param   {number[]} key - Key to be used to encrypt plaintext.\n     * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n     * @returns {number[]} Ciphertext as byte array.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"nistEncryption\",\n    value: function nistEncryption(plaintext, key, counterBlock) {\n      var blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n      // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n      var keySchedule = Aes.keyExpansion(key);\n      var blockCount = Math.ceil(plaintext.length / blockSize);\n      var ciphertext = new Array(plaintext.length);\n\n      for (var b = 0; b < blockCount; b++) {\n        // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n        var blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1; // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n\n        for (var i = 0; i < blockLength; i++) {\n          ciphertext[b * blockSize + i] = cipherCntr[i] ^ plaintext[b * blockSize + i];\n        } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n        counterBlock[blockSize - 1]++; // and propagate carry digits\n\n        for (var _i = blockSize - 1; _i >= 8; _i--) {\n          counterBlock[_i - 1] += counterBlock[_i] >> 8;\n          counterBlock[_i] &= 0xff;\n        } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n        if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n          if (b % 1000 == 0) self.postMessage({\n            progress: b / blockCount\n          });\n        }\n      }\n\n      return ciphertext;\n    }\n    /**\n     * Decrypt a text encrypted by AES in counter mode of operation.\n     *\n     * @param   {string} ciphertext - Cipher text to be decrypted.\n     * @param   {string} password - Password to use to generate a key for decryption.\n     * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n     * @returns {string} Decrypted text\n     *\n     * @example\n     *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext, password, nBits) {\n      if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n      ciphertext = AesCtr.base64Decode(String(ciphertext));\n      password = AesCtr.utf8Encode(String(password)); // use AES to encrypt password (mirroring encrypt routine)\n\n      var nBytes = nBits / 8; // no bytes in key\n\n      var pwBytes = new Array(nBytes);\n\n      for (var i = 0; i < nBytes; i++) {\n        // use 1st nBytes chars of password for key\n        pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n      }\n\n      var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n      key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n      // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n\n      var counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n      for (var _i2 = 0; _i2 < 8; _i2++) {\n        counterBlock[_i2] = ciphertext.charCodeAt(_i2);\n      } // convert ciphertext to byte array (skipping past initial 8 bytes)\n\n\n      var ciphertextBytes = new Array(ciphertext.length - 8);\n\n      for (var _i3 = 8; _i3 < ciphertext.length; _i3++) {\n        ciphertextBytes[_i3 - 8] = ciphertext.charCodeAt(_i3);\n      } // ------------ perform decryption ------------\n\n\n      var plaintextBytes = AesCtr.nistDecryption(ciphertextBytes, key, counterBlock); // convert byte array to (utf-8) plaintext string\n\n      var plaintextUtf8 = plaintextBytes.map(function (i) {\n        return String.fromCharCode(i);\n      }).join(\"\"); // decode from UTF8 back to Unicode multi-byte chars\n\n      var plaintext = AesCtr.utf8Decode(plaintextUtf8);\n      return plaintext;\n    }\n    /**\n     * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n     * operations. This implements the §6.5 Counter Mode (CTR).\n     *\n     *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n     *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n     *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n     *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n     *   plaintext blocks\n     *\n     * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n     * @param   {number[]} key - Key to be used to decrypt ciphertext.\n     * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n     * @returns {number[]} Plaintext as byte array.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"nistDecryption\",\n    value: function nistDecryption(ciphertext, key, counterBlock) {\n      var blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n      // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n      var keySchedule = Aes.keyExpansion(key);\n      var blockCount = Math.ceil(ciphertext.length / blockSize);\n      var plaintext = new Array(ciphertext.length);\n\n      for (var b = 0; b < blockCount; b++) {\n        // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n        var blockLength = b < blockCount - 1 ? blockSize : (ciphertext.length - 1) % blockSize + 1; // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n\n        for (var i = 0; i < blockLength; i++) {\n          plaintext[b * blockSize + i] = cipherCntr[i] ^ ciphertext[b * blockSize + i];\n        } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n        counterBlock[blockSize - 1]++; // and propagate carry digits\n\n        for (var _i4 = blockSize - 1; _i4 >= 8; _i4--) {\n          counterBlock[_i4 - 1] += counterBlock[_i4] >> 8;\n          counterBlock[_i4] &= 0xff;\n        } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n        if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n          if (b % 1000 == 0) self.postMessage({\n            progress: b / blockCount\n          });\n        }\n      }\n\n      return plaintext;\n    }\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n    /**\n     * Encodes multi-byte string to utf8.\n     *\n     * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n     * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n     */\n\n  }, {\n    key: \"utf8Encode\",\n    value: function utf8Encode(str) {\n      try {\n        return new TextEncoder().encode(str, \"utf-8\").reduce(function (prev, curr) {\n          return prev + String.fromCharCode(curr);\n        }, \"\");\n      } catch (e) {\n        // no TextEncoder available?\n        return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n      }\n    }\n    /**\n     * Decodes utf8 string to multi-byte.\n     */\n\n  }, {\n    key: \"utf8Decode\",\n    value: function utf8Decode(str) {\n      try {\n        return new TextEncoder().decode(str, \"utf-8\").reduce(function (prev, curr) {\n          return prev + String.fromCharCode(curr);\n        }, \"\");\n      } catch (e) {\n        // no TextEncoder available?\n        return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n      }\n    }\n    /*\n     * Encodes string as base-64.\n     *\n     * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n     * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n     * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n     */\n\n  }, {\n    key: \"base64Encode\",\n    value: function base64Encode(str) {\n      if (typeof btoa != \"undefined\") return btoa(str); // browser\n\n      if (typeof Buffer != \"undefined\") return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n\n      throw new Error(\"No Base64 Encode\");\n    }\n    /*\n     * Decodes base-64 encoded string.\n     */\n\n  }, {\n    key: \"base64Decode\",\n    value: function base64Decode(str) {\n      if (typeof atob != \"undefined\") return atob(str); // browser\n\n      if (typeof Buffer != \"undefined\") return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n\n      throw new Error(\"No Base64 Decode\");\n    }\n  }]);\n\n  return AesCtr;\n}(Aes);\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport default AesCtr;","map":null,"metadata":{},"sourceType":"module"}