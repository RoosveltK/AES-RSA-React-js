{"ast":null,"code":"import Aes from \"./Aes.js\";\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\n\nclass AesCtr extends Aes {\n  /**\n   * Encrypt a text using AES encryption in Counter mode of operation.\n   *\n   * Unicode multi-byte character safe.\n   *\n   * @param   {string} plaintext - Source text to be encrypted.\n   * @param   {string} password - The password to use to generate a key for encryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Encrypted text, base-64 encoded.\n   *\n   * @example\n   *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n   */\n  static encrypt(plaintext, password, nBits) {\n    if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n    plaintext = AesCtr.utf8Encode(String(plaintext));\n    password = AesCtr.utf8Encode(String(password)); // use AES itself to encrypt password to get cipher key (using plain password as source for key\n    // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n\n    const nBytes = nBits / 8; // no bytes in key (16/24/32)\n\n    const pwBytes = new Array(nBytes);\n\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st 16/24/32 chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n    // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n    // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n\n    const timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n\n    const nonceMs = timestamp % 1000;\n    const nonceSec = Math.floor(timestamp / 1000);\n    const nonceRnd = Math.floor(Math.random() * 0xffff); // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n\n    const counterBlock = [// 16-byte array; blocksize is fixed at 16 for AES\n    nonceMs & 0xff, nonceMs >>> 8 & 0xff, nonceRnd & 0xff, nonceRnd >>> 8 & 0xff, nonceSec & 0xff, nonceSec >>> 8 & 0xff, nonceSec >>> 16 & 0xff, nonceSec >>> 24 & 0xff, 0, 0, 0, 0, 0, 0, 0, 0]; // and convert nonce to a string to go on the front of the ciphertext\n\n    const nonceStr = counterBlock.slice(0, 8).map(i => String.fromCharCode(i)).join(\"\"); // convert (utf-8) plaintext to byte array\n\n    const plaintextBytes = plaintext.split(\"\").map(ch => ch.charCodeAt(0)); // ------------ perform encryption ------------\n\n    const ciphertextBytes = AesCtr.nistEncryption(plaintextBytes, key, counterBlock); // convert byte array to (utf-8) ciphertext string\n\n    const ciphertextUtf8 = ciphertextBytes.map(i => String.fromCharCode(i)).join(\"\"); // base-64 encode ciphertext\n\n    const ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n    return ciphertextB64;\n  }\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n   *   ciphertext blocks\n   *\n   * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n   * @param   {number[]} key - Key to be used to encrypt plaintext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Ciphertext as byte array.\n   *\n   * @private\n   */\n\n\n  static nistEncryption(plaintext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n    const keySchedule = Aes.keyExpansion(key);\n    const blockCount = Math.ceil(plaintext.length / blockSize);\n    const ciphertext = new Array(plaintext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n      const blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1; // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n\n      for (let i = 0; i < blockLength; i++) {\n        ciphertext[b * blockSize + i] = cipherCntr[i] ^ plaintext[b * blockSize + i];\n      } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n      counterBlock[blockSize - 1]++; // and propagate carry digits\n\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n      if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (b % 1000 == 0) self.postMessage({\n          progress: b / blockCount\n        });\n      }\n    }\n\n    return ciphertext;\n  }\n  /**\n   * Decrypt a text encrypted by AES in counter mode of operation.\n   *\n   * @param   {string} ciphertext - Cipher text to be decrypted.\n   * @param   {string} password - Password to use to generate a key for decryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Decrypted text\n   *\n   * @example\n   *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n   */\n\n\n  static decrypt(ciphertext, password, nBits) {\n    if (![128, 192, 256].includes(nBits)) throw new Error(\"Key size is not 128 / 192 / 256\");\n    ciphertext = AesCtr.base64Decode(String(ciphertext));\n    password = AesCtr.utf8Encode(String(password)); // use AES to encrypt password (mirroring encrypt routine)\n\n    const nBytes = nBits / 8; // no bytes in key\n\n    const pwBytes = new Array(nBytes);\n\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st nBytes chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n    // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n\n    const counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    for (let i = 0; i < 8; i++) counterBlock[i] = ciphertext.charCodeAt(i); // convert ciphertext to byte array (skipping past initial 8 bytes)\n\n\n    const ciphertextBytes = new Array(ciphertext.length - 8);\n\n    for (let i = 8; i < ciphertext.length; i++) ciphertextBytes[i - 8] = ciphertext.charCodeAt(i); // ------------ perform decryption ------------\n\n\n    const plaintextBytes = AesCtr.nistDecryption(ciphertextBytes, key, counterBlock); // convert byte array to (utf-8) plaintext string\n\n    const plaintextUtf8 = plaintextBytes.map(i => String.fromCharCode(i)).join(\"\"); // decode from UTF8 back to Unicode multi-byte chars\n\n    const plaintext = AesCtr.utf8Decode(plaintextUtf8);\n    return plaintext;\n  }\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n   *   plaintext blocks\n   *\n   * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n   * @param   {number[]} key - Key to be used to decrypt ciphertext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Plaintext as byte array.\n   *\n   * @private\n   */\n\n\n  static nistDecryption(ciphertext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n\n    const keySchedule = Aes.keyExpansion(key);\n    const blockCount = Math.ceil(ciphertext.length / blockSize);\n    const plaintext = new Array(ciphertext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule); // block size is reduced on final block\n\n      const blockLength = b < blockCount - 1 ? blockSize : (ciphertext.length - 1) % blockSize + 1; // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n\n      for (let i = 0; i < blockLength; i++) {\n        plaintext[b * blockSize + i] = cipherCntr[i] ^ ciphertext[b * blockSize + i];\n      } // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n\n\n      counterBlock[blockSize - 1]++; // and propagate carry digits\n\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      } // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n\n\n      if (typeof WorkerGlobalScope != \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (b % 1000 == 0) self.postMessage({\n          progress: b / blockCount\n        });\n      }\n    }\n\n    return plaintext;\n  }\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n  /**\n   * Encodes multi-byte string to utf8.\n   *\n   * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n   * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n   */\n\n\n  static utf8Encode(str) {\n    try {\n      return new TextEncoder().encode(str, \"utf-8\").reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n  /**\n   * Decodes utf8 string to multi-byte.\n   */\n\n\n  static utf8Decode(str) {\n    try {\n      return new TextEncoder().decode(str, \"utf-8\").reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n  /*\n   * Encodes string as base-64.\n   *\n   * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n   * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n   * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n   */\n\n\n  static base64Encode(str) {\n    if (typeof btoa != \"undefined\") return btoa(str); // browser\n\n    if (typeof Buffer != \"undefined\") return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n\n    throw new Error(\"No Base64 Encode\");\n  }\n  /*\n   * Decodes base-64 encoded string.\n   */\n\n\n  static base64Decode(str) {\n    if (typeof atob != \"undefined\") return atob(str); // browser\n\n    if (typeof Buffer != \"undefined\") return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n\n    throw new Error(\"No Base64 Decode\");\n  }\n\n}\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport default AesCtr;","map":{"version":3,"sources":["/media/roosvelt/SAVE_IMP1/ICT4D/ICT4D-L2/S2/ICT214/KENNE_NGNINPIA_ROOSVELT_19K2782/rsa-aes/public/AesCtr.js"],"names":["Aes","AesCtr","encrypt","plaintext","password","nBits","includes","Error","utf8Encode","String","nBytes","pwBytes","Array","i","length","charCodeAt","key","cipher","keyExpansion","concat","slice","timestamp","Date","getTime","nonceMs","nonceSec","Math","floor","nonceRnd","random","counterBlock","nonceStr","map","fromCharCode","join","plaintextBytes","split","ch","ciphertextBytes","nistEncryption","ciphertextUtf8","ciphertextB64","base64Encode","blockSize","keySchedule","blockCount","ceil","ciphertext","b","cipherCntr","blockLength","WorkerGlobalScope","self","postMessage","progress","decrypt","base64Decode","nistDecryption","plaintextUtf8","utf8Decode","str","TextEncoder","encode","reduce","prev","curr","e","unescape","encodeURIComponent","decode","decodeURIComponent","escape","btoa","Buffer","toString","atob"],"mappings":"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","sourcesContent":["import Aes from \"./Aes.js\";\n\n/**\n * AesCtr: Counter-mode (CTR) wrapper for AES.\n *\n * This encrypts a Unicode string to produces a base64 ciphertext using 128/192/256-bit AES,\n * and the converse to decrypt an encrypted ciphertext.\n *\n * See csrc.nist.gov/publications/detail/sp/800-38a/final\n */\nclass AesCtr extends Aes {\n  /**\n   * Encrypt a text using AES encryption in Counter mode of operation.\n   *\n   * Unicode multi-byte character safe.\n   *\n   * @param   {string} plaintext - Source text to be encrypted.\n   * @param   {string} password - The password to use to generate a key for encryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Encrypted text, base-64 encoded.\n   *\n   * @example\n   *   const encr = AesCtr.encrypt('big secret', 'pāşšŵōřđ', 256); // 'lwGl66VVwVObKIr6of8HVqJr'\n   */\n  static encrypt(plaintext, password, nBits) {\n    if (![128, 192, 256].includes(nBits))\n      throw new Error(\"Key size is not 128 / 192 / 256\");\n    plaintext = AesCtr.utf8Encode(String(plaintext));\n    password = AesCtr.utf8Encode(String(password));\n\n    // use AES itself to encrypt password to get cipher key (using plain password as source for key\n    // expansion) to give us well encrypted key (in real use hashed password could be used for key)\n    const nBytes = nBits / 8; // no bytes in key (16/24/32)\n    const pwBytes = new Array(nBytes);\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st 16/24/32 chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes)); // gives us 16-byte key\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n\n    // initialise 1st 8 bytes of counter block with nonce (NIST SP 800-38A §B.2): [0-1] = millisec,\n    // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106\n    const timestamp = new Date().getTime(); // milliseconds since 1-Jan-1970\n    const nonceMs = timestamp % 1000;\n    const nonceSec = Math.floor(timestamp / 1000);\n    const nonceRnd = Math.floor(Math.random() * 0xffff);\n    // for debugging: const [ nonceMs, nonceSec, nonceRnd ] = [ 0, 0, 0 ];\n    const counterBlock = [\n      // 16-byte array; blocksize is fixed at 16 for AES\n      nonceMs & 0xff,\n      (nonceMs >>> 8) & 0xff,\n      nonceRnd & 0xff,\n      (nonceRnd >>> 8) & 0xff,\n      nonceSec & 0xff,\n      (nonceSec >>> 8) & 0xff,\n      (nonceSec >>> 16) & 0xff,\n      (nonceSec >>> 24) & 0xff,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n    ];\n\n    // and convert nonce to a string to go on the front of the ciphertext\n    const nonceStr = counterBlock\n      .slice(0, 8)\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // convert (utf-8) plaintext to byte array\n    const plaintextBytes = plaintext.split(\"\").map((ch) => ch.charCodeAt(0));\n\n    // ------------ perform encryption ------------\n    const ciphertextBytes = AesCtr.nistEncryption(\n      plaintextBytes,\n      key,\n      counterBlock\n    );\n\n    // convert byte array to (utf-8) ciphertext string\n    const ciphertextUtf8 = ciphertextBytes\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // base-64 encode ciphertext\n    const ciphertextB64 = AesCtr.base64Encode(nonceStr + ciphertextUtf8);\n\n    return ciphertextB64;\n  }\n\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Cⱼ = Pⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     C*ₙ = P* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, P plaintext blocks, C\n   *   ciphertext blocks\n   *\n   * @param   {number[]} plaintext - Plaintext to be encrypted, as byte array.\n   * @param   {number[]} key - Key to be used to encrypt plaintext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Ciphertext as byte array.\n   *\n   * @private\n   */\n  static nistEncryption(plaintext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n    const keySchedule = Aes.keyExpansion(key);\n\n    const blockCount = Math.ceil(plaintext.length / blockSize);\n    const ciphertext = new Array(plaintext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- encrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule);\n\n      // block size is reduced on final block\n      const blockLength =\n        b < blockCount - 1\n          ? blockSize\n          : ((plaintext.length - 1) % blockSize) + 1;\n\n      // ---- xor plaintext with ciphered counter byte-by-byte; Cⱼ = Pⱼ ⊕ Oⱼ ----\n      for (let i = 0; i < blockLength; i++) {\n        ciphertext[b * blockSize + i] =\n          cipherCntr[i] ^ plaintext[b * blockSize + i];\n      }\n\n      // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n      counterBlock[blockSize - 1]++;\n      // and propagate carry digits\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      }\n\n      // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n      if (\n        typeof WorkerGlobalScope != \"undefined\" &&\n        self instanceof WorkerGlobalScope\n      ) {\n        if (b % 1000 == 0) self.postMessage({ progress: b / blockCount });\n      }\n    }\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypt a text encrypted by AES in counter mode of operation.\n   *\n   * @param   {string} ciphertext - Cipher text to be decrypted.\n   * @param   {string} password - Password to use to generate a key for decryption.\n   * @param   {number} nBits - Number of bits to be used in the key; 128 / 192 / 256.\n   * @returns {string} Decrypted text\n   *\n   * @example\n   *   const decr = AesCtr.decrypt('lwGl66VVwVObKIr6of8HVqJr', 'pāşšŵōřđ', 256); // 'big secret'\n   */\n  static decrypt(ciphertext, password, nBits) {\n    if (![128, 192, 256].includes(nBits))\n      throw new Error(\"Key size is not 128 / 192 / 256\");\n    ciphertext = AesCtr.base64Decode(String(ciphertext));\n    password = AesCtr.utf8Encode(String(password));\n\n    // use AES to encrypt password (mirroring encrypt routine)\n    const nBytes = nBits / 8; // no bytes in key\n    const pwBytes = new Array(nBytes);\n    for (let i = 0; i < nBytes; i++) {\n      // use 1st nBytes chars of password for key\n      pwBytes[i] = i < password.length ? password.charCodeAt(i) : 0;\n    }\n    let key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n    key = key.concat(key.slice(0, nBytes - 16)); // expand key to 16/24/32 bytes long\n\n    // recover nonce from 1st 8 bytes of ciphertext into 1st 8 bytes of counter block\n    const counterBlock = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let i = 0; i < 8; i++) counterBlock[i] = ciphertext.charCodeAt(i);\n\n    // convert ciphertext to byte array (skipping past initial 8 bytes)\n    const ciphertextBytes = new Array(ciphertext.length - 8);\n    for (let i = 8; i < ciphertext.length; i++)\n      ciphertextBytes[i - 8] = ciphertext.charCodeAt(i);\n\n    // ------------ perform decryption ------------\n    const plaintextBytes = AesCtr.nistDecryption(\n      ciphertextBytes,\n      key,\n      counterBlock\n    );\n\n    // convert byte array to (utf-8) plaintext string\n    const plaintextUtf8 = plaintextBytes\n      .map((i) => String.fromCharCode(i))\n      .join(\"\");\n\n    // decode from UTF8 back to Unicode multi-byte chars\n    const plaintext = AesCtr.utf8Decode(plaintextUtf8);\n\n    return plaintext;\n  }\n\n  /**\n   * NIST SP 800-38A sets out recommendations for block cipher modes of operation in terms of byte\n   * operations. This implements the §6.5 Counter Mode (CTR).\n   *\n   *     Oⱼ = CIPHₖ(Tⱼ)      for j = 1, 2 … n\n   *     Pⱼ = Cⱼ ⊕ Oⱼ        for j = 1, 2 … n-1\n   *     P*ₙ = C* ⊕ MSBᵤ(Oₙ) final (partial?) block\n   *   where CIPHₖ is the forward cipher function, O output blocks, C ciphertext blocks, P\n   *   plaintext blocks\n   *\n   * @param   {number[]} ciphertext - Ciphertext to be decrypted, as byte array.\n   * @param   {number[]} key - Key to be used to decrypt ciphertext.\n   * @param   {number[]} counterBlock - Initial 16-byte CTR counter block (with nonce & 0 counter).\n   * @returns {number[]} Plaintext as byte array.\n   *\n   * @private\n   */\n  static nistDecryption(ciphertext, key, counterBlock) {\n    const blockSize = 16; // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n\n    // generate key schedule - an expansion of the key into distinct Key Rounds for each round\n    const keySchedule = Aes.keyExpansion(key);\n\n    const blockCount = Math.ceil(ciphertext.length / blockSize);\n    const plaintext = new Array(ciphertext.length);\n\n    for (let b = 0; b < blockCount; b++) {\n      // ---- decrypt counter block; Oⱼ = CIPHₖ(Tⱼ) ----\n      const cipherCntr = Aes.cipher(counterBlock, keySchedule);\n\n      // block size is reduced on final block\n      const blockLength =\n        b < blockCount - 1\n          ? blockSize\n          : ((ciphertext.length - 1) % blockSize) + 1;\n\n      // ---- xor ciphertext with ciphered counter byte-by-byte; Pⱼ = Cⱼ ⊕ Oⱼ ----\n      for (let i = 0; i < blockLength; i++) {\n        plaintext[b * blockSize + i] =\n          cipherCntr[i] ^ ciphertext[b * blockSize + i];\n      }\n\n      // increment counter block (counter in 2nd 8 bytes of counter block, big-endian)\n      counterBlock[blockSize - 1]++;\n      // and propagate carry digits\n      for (let i = blockSize - 1; i >= 8; i--) {\n        counterBlock[i - 1] += counterBlock[i] >> 8;\n        counterBlock[i] &= 0xff;\n      }\n\n      // if within web worker, announce progress every 1000 blocks (roughly every 50ms)\n      if (\n        typeof WorkerGlobalScope != \"undefined\" &&\n        self instanceof WorkerGlobalScope\n      ) {\n        if (b % 1000 == 0) self.postMessage({ progress: b / blockCount });\n      }\n    }\n\n    return plaintext;\n  }\n\n  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n  /**\n   * Encodes multi-byte string to utf8.\n   *\n   * Note utf8Encode is an identity function with 7-bit ascii strings, but not with 8-bit strings;\n   * utf8Encode('x') = 'x', but utf8Encode('ça') = 'Ã§a', and utf8Encode('Ã§a') = 'ÃÂ§a'.\n   */\n  static utf8Encode(str) {\n    try {\n      return new TextEncoder()\n        .encode(str, \"utf-8\")\n        .reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n\n  /**\n   * Decodes utf8 string to multi-byte.\n   */\n  static utf8Decode(str) {\n    try {\n      return new TextEncoder()\n        .decode(str, \"utf-8\")\n        .reduce((prev, curr) => prev + String.fromCharCode(curr), \"\");\n    } catch (e) {\n      // no TextEncoder available?\n      return decodeURIComponent(escape(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n    }\n  }\n\n  /*\n   * Encodes string as base-64.\n   *\n   * - developer.mozilla.org/en-US/docs/Web/API/window.btoa, nodejs.org/api/buffer.html\n   * - note: btoa & Buffer/binary work on single-byte Unicode (C0/C1), so ok for utf8 strings, not for general Unicode...\n   * - note: if btoa()/atob() are not available (eg IE9-), try github.com/davidchambers/Base64.js\n   */\n  static base64Encode(str) {\n    if (typeof btoa != \"undefined\") return btoa(str); // browser\n    if (typeof Buffer != \"undefined\")\n      return new Buffer(str, \"binary\").toString(\"base64\"); // Node.js\n    throw new Error(\"No Base64 Encode\");\n  }\n\n  /*\n   * Decodes base-64 encoded string.\n   */\n  static base64Decode(str) {\n    if (typeof atob != \"undefined\") return atob(str); // browser\n    if (typeof Buffer != \"undefined\")\n      return new Buffer(str, \"base64\").toString(\"binary\"); // Node.js\n    throw new Error(\"No Base64 Decode\");\n  }\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default AesCtr;\n"]},"metadata":{},"sourceType":"module"}